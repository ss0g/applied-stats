---
title: "Analysis of the Various Factors Influencing the Success of FRC Teams"
author: "Troy Edwards"
date: "2023--06--16"
documentclass: article
output:
    pdf_document:
        number_sections: True
header_includes:
    \usepackage{amsmath}
    \allowdisplaybreaks
fontsize: 12pt
geometry:
    margin=1in
---

```{r setup, include=F}
if (.Platform$OS.type == "unix") {
    setwd("/home/ss0g/school/applied-stats/s2/final")
} else {
    setwd("C:\\Users\\tntje\\work\\school\\applied-stats\\s2\\final")
}

library(tidyverse)
library(ggplot2)
library(pivottabler)
library(httr)
library(jsonlite)
library(sets)

dotenv::load_dot_env()

frc_events_api_token <- Sys.getenv("FRC_TOKEN")
tba_api_token <- Sys.getenv("TBA_TOKEN")

tba_base_url <- "https://thebluealliance.com/api/v3/"

sample_size <- 30

waahs_2022 <- read.csv("./Auburn Scouting 2022 - Data.csv") # auburn
pncmp_2022 <- read.csv("./Public Copy of Cheney District Scouting 4915 2022 - Data.csv") # districts

wasno_2023 <- read.csv("./Copy of 4915 Scouting 2023 - Glacier Peak State - Data.csv") # glacier peak
waahs_2023 <- read.csv("./Copy of 4915 Scouting 2023 - April 4, 7 33 PM - Auburn Data.csv") # auburn
pncmp_2023 <- read.csv("./Copy of 4915 Scouting 2023 - April 12, 1 20 PM - Data.csv") # districts
```

\tableofcontents

\begin{abstract}
\textbf{TODO}
\end{abstract}

\section{Introduction}

FIRST Robotics Competition is a robotics competition in which teams of high schoolers build robots to compete in a game
that is different every year.. FIRST is the organization that runs these competitions, and the acronym FIRST stands for
"For the Inspiration and Recognition of Science and Technology." Each year, FIRST reveals a new game in which alliances
of 3 industrial-size robots compete against each other on a field to complete various tasks. Teams have limited time
after "Kickoff" (the game reveal) to design, build, wire, and program their robot to perform the tasks required for the
game. For example, in this year.'s game, CHARGED UP, robots must travel across the field to the Substation Area to pick
up one game piece (a cube or a cone) at a time and then travel back to their alliance's Grid and deposit the pieces
onto Nodes. 

There are many factors that could have an effect on a team's success. These include general things about the team, such
as the team's age, its budget, and its size, and also things about their robot in a specific season, such as drivetrain
type and scoring capability. The goal of this research is to determine which of these factors have the greatest effect
on a team's success. 

\section{Literature Review}

<!-- There is not much work that has already been done on this topic. I managed to find 2 papers: ``An Analysis of the
Success of FRC Robotics Teams'' by Max Tepermeister and ``An Overview and Analysis of Statistics used to Rate FIRST
Robotics Teams'' by William Gardner. The first one is not a paper that I would consider ``scholarly'' because it is a
high-schooler's final project for AP Statistics, but the second one appears formal and well-organized. However,
Gardner's paper is not fully on-topic, as it analyzes metrics used to rate FRC teams. The information presented is
still relevant, just not directly applicable. Tepermeister's objective was similar to mine. Tepermeister mainly
analyzed the effects of the age, size, and budget of a team on its success. Tepermeister found that none of these
factors have a significant effect on success.  -->

There is not much work that has been done on this topic. The most relevant paper that I could find was "An analysis of
the Success of FRC Robotics Teams" by Max Tepermeister. Tepermeister found that team age had a small amount of
correlation with success, while team budget and team size had no correlation with success. However, Tepermeister used
OPR (offensive power rating) rather than win rate to measure a team's success, which means that his results could be
different from mine. 

\section{Method}

\subsection{Analysis of individual variables}

I plan to analyze whether several variables have a significant influence on a team's success. Only qualification
matches will be analyzed because the alliances are random and the data only covers scouting matches. \textbf{TODO: ADD MORE HERE (HOW IS SUCCESS MEASURED?)}
<!-- TODO -->

\subsubsection{Drivetrain}

A robot's drivetrain can have a huge influence on how successful it is. FRC games are typically quite fast-paced, so a
better drivetrain can make a huge difference. For most games, the playing field is quite flat, with few obstacles to
overcome. This is true of both RAPID REACT and CHARGED UP. In games with few obstacles, teams will typically use some
sort of "normal" drivetrain (i.e. one without huge wheels or anything like that). The three main types of drivetrain
typically found in FRC are:
\begin{enumerate}
    \item Differential
    \item Mecanum
    \item Swerve
\end{enumerate}
A differential drive has normal wheels on the left and right sides of the robot. A Mecanum drive uses Mecanum wheels,
which are special wheels with diagonal rollers mounted around the circumference. A robot with a mecanum drivetrain can
drive forwards and backwards, similar to a differential drivetrain, but it can also drive sideways by driving specific
wheels in specific directions. A swerve drive is another type of drivetrain that can drive in any direction, but unlike
the Mecanum drivetrain, the swerve drive achieves this by using two motors for each wheel: one to drive the wheel, and
another to steer the wheel. This allows each wheel to be steered independently of the others, which allows for complex
maneuvers.

<!-- TODO: maybe a picture of a mecanum wheel and/or a swerve module here? -->

These can be grouped into two categories, namely holonomic (Mecanum and swerve) and non-holonomic (differential). The
difference between these two categories is that while a non-holonomic drivetrain constrains a robot to only move
forwards and backwards such that it must turn to change its direction of motion, a holonomic drivetrain is free of
these constraints. 

A differential drive is usually the cheapest, since it requires no special parts. The next cheapest of these three is
the Mecanum drive because you only need the 4 wheels and a motor for each. However, one major drawback of a Mecanum
drivetrain is that the wheels are more prone to slipping. This means that a robot with a Mecanum drivetrain has a lower
maximum acceleration before the wheels start to slip. It also means that in FRC, a robot with a Mecanum drivetrain is
very easy to play defense against because a robot with a differential drive or a swerve drive can easily shove it
it around. Finally, the most expensive, but also the most effective is the swerve drive. The swerve drive combines the
lack of slip (and by extension, pushing power) of a differential drivetrain with the flexibility of a holonomic
drivetrain. The main drawback of swerve drive is that it can at times be prohibitively expensive, with a single swerve
module typically costing upwards of $300 not even including the motors. This is because they are very complex, with
lots of gears and custom machined parts. 

<!-- To analyze the effect of drivetrain on a team's success, I will perform two inference tests: 
\begin{enumerate}
    \item A two sample difference of means $t$-test to compare the success of teams using holonomic and non-holonomic
    drivetrains
    \item A one-way ANOVA test to see if the difference in success is any greater if Mecanum and Swerve are not grouped
    together
\end{enumerate} -->

To analyze the effect of drivetrain on a team's success, I will perform a two sample difference of means $t$-test to
compare the win rate of teams with holonomic drivetrains to teams without holonomic drivetrains.

\subsubsection{School budget}

A school's budget can have a huge influence on a team's budget, which can in turn influence the team's success by
allowing them to use more complex tools, purchase higher-end parts, and go to more events. 
<!-- TODO: add more content here -->
<!-- FIXME: maybe change to school budget -->

To analyze the effect of budget on a robot's success, I will create a model using school expenditures per pupil to
predict win rate and perform a $t$-test for slope to see if the relationship is significant. 

\subsubsection{Team age}
An older team will likely have more advanced techniques and manufacturing processes at its disposal, while a younger
team will typically not have these things. Team number is a good proxy to team age because the team numbers are
assigned sequentially. 

To analyze the effect of a team's age on its success, I will create a model using team age to predict win rate and
perform a $t$-test for slope to see if the relationship is significant.

\subsection{Predictive models}

<!-- After analyzing individual variables, I will create two models:
\begin{enumerate}
    \item A multiple linear regression model using a combination of the above variables to predict a team's overall win
    rate
    \item A multiple logistic regression model using a combination of the above variables and various metrics from a
    robot's allies and opponents to predict whether a robot will win a specific match
\end{enumerate} -->

After analyzing individual variables, I will create a multiple linear regression model using a combination of the above
variables to predict a team's overall win rate

\subsection{Data collection and sources}

My data comes from three main sources:
\begin{enumerate}
    \item Evan Kuykendall's 2023 scouting data from Glacier Peak, Auburn, and the Pacific Northwest District
    Championship
    \item Jake Benjamin's 2022 scouting data from Auburn and the Pacific Northwest District Championship
    \item The Blue Alliance
\end{enumerate}

The scouting datasets contain information about each robot in every match that was scouted. An example of something
that would be included in the data for 2022 would be number of pieces scored in the UPPER HUB while an example of
something that would be included in the data for 2023 would be number of pieces scored in HYBRID NODES. The Blue
Alliance only has more general data, such as match results (win/loss). However, it also contains information about who
was on what alliance for a specific match. This will be useful for gathering data about alliance members to use in the
logistic regression model. I also have data from the Department of Education for the inference test with school
expenditures. 

```{r sampling, include=F}
union3 <- \(x, y, z) union(x, union(y, z))

all_teams_2022 <- na.omit(union(
    unique(waahs_2022$Team.Number..ex..4915.),
    unique(pncmp_2022$Team.Number..ex..4915.)
))

all_teams_2023 <- na.omit(union3(
    unique(wasno_2023$Team.Number.you.re.scouting),
    unique(waahs_2023$Team.Number.you.re.scouting),
    unique(pncmp_2023$Team.Number.you.re.scouting)
))

select_sample_2022 <- function() {
    set.seed(3)
    teams <- sample(all_teams_2022, sample_size)
    return(teams)
}

select_sample_2023 <- function() {
    set.seed(13)
    teams <- sample(all_teams_2023, sample_size)
    return(teams)
}

teams_2022 <- select_sample_2022()
teams_2023 <- select_sample_2023()

print(teams_2022)
print(teams_2023)

teams_df_2022 <- data.frame("team" = teams_2022, "year" = rep(2022, 30))
teams_df_2023 <- data.frame("team" = teams_2023, "year" = rep(2023, 30))

pt_teams <- bind_rows(teams_df_2022, teams_df_2023)
```

```{r organization, include=F}
waahs_2022$event <- "waahs"
pncmp_2022$event <- "pncmp"

wasno_2023$event <- "wasno"
waahs_2023$event <- "waahs"
pncmp_2023$event <- "pncmp"

all_data_2022_raw <- bind_rows(waahs_2022, pncmp_2022)
all_data_2023_raw <- bind_rows(wasno_2023, waahs_2023, pncmp_2023)

all_data_2022_raw <- all_data_2022_raw |> replace(is.na(all_data_2022_raw), 0)
all_data_2023_raw <- all_data_2023_raw |> replace(is.na(all_data_2023_raw), 0)

all_data_2022_raw <- all_data_2022_raw[all_data_2022_raw$Match.. > 0,] # nolint
all_data_2023_raw <- all_data_2023_raw[all_data_2023_raw$Match.. > 0,] # nolint

all_data_2022_raw <- all_data_2022_raw[!duplicated(all_data_2022_raw[c("Match..", "Team.Number..ex..4915."),]),] # nolint
all_data_2023_raw <- all_data_2023_raw[!duplicated(all_data_2023_raw[c("Match..", "Team.Number.you.re.scouting"),]),] # nolint

rownames(all_data_2022_raw) <- NULL
rownames(all_data_2023_raw) <- NULL

yn_to_tf <- \(x) switch(x, "Yes" = T, "No" = F, NULL) # nolint
replace_if_null <- \(x, replace_with) ifelse(is.null(x), replace_with, x)

endgame_points_2022 <- \(climb_level) switch(climb_level, 4, 6, 10, 15) |> replace_if_null(0)
endgame_points_2023 <- \(endgame_status) switch(endgame_status, "Not Parked" = 0, "Parked" = 2, "Docked" = 6, "Engaged" = 10) |> replace_if_null(0) # nolint

auto_cs_points_2023 <- \(end_of_auto_status) switch(end_of_auto_status, "Not Docked" = 0, "Docked" = 8, "Engaged" = 12) |> replace_if_null(0) # nolint

all_data_2022 <- data.frame(
    team_number = all_data_2022_raw$Team.Number..ex..4915.,
    event = all_data_2022_raw$event,
    match_number = all_data_2022_raw$Match..,
    taxied = ifelse(all_data_2022_raw$Did.it.taxi..move.in.auto.. == "Yes", T, F), # nolint
    auto_low_goals = all_data_2022_raw$X..of.Low.Goals.Scored,
    auto_high_goals = all_data_2022_raw$X..of.High.Goals.Scored,
    teleop_low_goals = all_data_2022_raw$X..of.Low.Goals.Scored.2,
    teleop_high_goals = all_data_2022_raw$X..of.High.Goals.Scored.2,
    climbed = all_data_2022_raw$Did.the.Robot.Climb.,
    climb_level = all_data_2022_raw$Climb.Level,
    total_auto_points = (
        all_data_2022_raw$X..of.Low.Goals.Scored * 2 +
        all_data_2022_raw$X..of.High.Goals.Scored * 4 +
        ifelse(all_data_2022_raw$Did.it.taxi..move.in.auto.. == "Yes", 2, 0)
    ),
    total_teleop_points = (
        all_data_2022_raw$X..of.Low.Goals.Scored.2 +
        all_data_2022_raw$X..of.High.Goals.Scored.2 * 2
    ),
    total_endgame_points = unlist(lapply(all_data_2022_raw$Climb.Level, endgame_points_2022))
)

all_data_2023 <- data.frame(
    team_number = all_data_2023_raw$Team.Number.you.re.scouting,
    event = all_data_2023_raw$event,
    match_number = all_data_2023_raw$Match..,
    mobility = ifelse(all_data_2023_raw$Mobility. == "Yes", T, F), # nolint
    end_of_auto_status = all_data_2023_raw$End.of.Auto.Status,
    auto_hybrid_cubes = all_data_2023_raw$Bottom.Cubes,
    auto_mid_cubes = all_data_2023_raw$Middle.Cubes,
    auto_high_cubes = all_data_2023_raw$Top.Cubes,
    auto_hybrid_cones = all_data_2023_raw$Bottom.Cones,
    auto_mid_cones = all_data_2023_raw$Middle.Cones,
    auto_high_cones = all_data_2023_raw$Top.Cones,
    teleop_hybrid_cubes = all_data_2023_raw$Bottom.Cubes.2,
    teleop_mid_cubes = all_data_2023_raw$Middle.Cubes.2,
    teleop_high_cubes = all_data_2023_raw$Top.Cubes.2,
    teleop_hybrid_cones = all_data_2023_raw$Bottom.Cones.2,
    teleop_mid_cones = all_data_2023_raw$Middle.Cones.2,
    teleop_high_cones = all_data_2023_raw$Top.Cones.2,
    endgame_status = all_data_2023_raw$Endgame.Status,
    total_auto_points = (
        ifelse(all_data_2023_raw$Mobility. == "Yes", 3, 0) +
        all_data_2023_raw$Bottom.Cubes * 3 +
        all_data_2023_raw$Middle.Cubes * 4 +
        all_data_2023_raw$Top.Cubes * 6 +
        all_data_2023_raw$Bottom.Cones * 3 +
        all_data_2023_raw$Middle.Cones * 4 +
        all_data_2023_raw$Top.Cones * 6 +
        unlist(lapply(all_data_2023_raw$End.of.Auto.Status, auto_cs_points_2023))
    ),
    total_teleop_points = (
        all_data_2023_raw$Bottom.Cubes.2 * 2 +
        all_data_2023_raw$Middle.Cubes.2 * 3 +
        all_data_2023_raw$Top.Cubes.2 * 5 +
        all_data_2023_raw$Bottom.Cones.2 * 2 +
        all_data_2023_raw$Middle.Cones.2 * 3 +
        all_data_2023_raw$Top.Cones.2 * 5
    ),
    total_endgame_points = unlist(lapply(all_data_2023_raw$Endgame.Status, endgame_points_2023))
)

all_data_2022 <- all_data_2022[all_data_2022$match_number > 0 & !is.na(all_data_2022$match_number),] # nolint
all_data_2023 <- all_data_2023[all_data_2023$match_number > 0 & !is.na(all_data_2023$match_number),] # nolint

rownames(all_data_2022) <- NULL
rownames(all_data_2023) <- NULL

get_match_key <- \(event, year., match_number) paste0(year., event, "_qm", match_number) # nolint

# This function retrieves the match data from The Blue Alliance for a given
# event, year, and match number. It is used to retrieve match data for the
# matches that are being processed.

get_match_data_from_tba <- function(event, year., match_number) { # nolint
    match_key <- get_match_key(event, year., match_number)
    req_url <- paste0(tba_base_url, "match/", match_key)
    req_res_raw <- GET(req_url, add_headers("X-TBA-Auth-Key" = tba_api_token))
    req_res <- content(req_res_raw, as = "text")
    result <- fromJSON(req_res)
    return(result)
}

test_match_data_2023 <- get_match_data_from_tba("waahs", 2023, 20)

# This code parses a team key from the TBA API.
# This is used in the TBA API to refer to a specific team.
# The team key is a string of the format "frcXXXX" where XXXX is the team number.
# This code parses the team number, which is an integer, from the team key.
# This code is used in the TBA API to refer to a specific team.

parse_team_key <- \(team_key) as.integer(substring(team_key, 4))

# Gets a list of the team numbers on an alliance in a given match.
# Args:
#   event: The event code for the event the match is in.
#   year.: The year of the event the match is in.
#   match_number: The number of the match.
#   alliance: The alliance to get the team numbers for.
# Returns:
#   A list of the team numbers on the given alliance in the given match.

get_teams_on_alliance_in_match <- function(event, year., match_number, alliance = c("red", "blue")) { # nolint
    match_data <- get_match_data_from_tba(event, year., match_number)
    alliances <- match_data$alliances
    alliance <- alliances[[alliance]]
    team_keys <- alliance$team_keys
    result <- as.vector(sapply(team_keys, parse_team_key), mode = "numeric")
    return(result)
}

get_teams_on_alliance_in_match_from_data <- function(match_data, alliance = c("red", "blue")) { # nolint
    alliances <- match_data$alliances
    alliance <- alliances[[alliance]]
    team_keys <- alliance$team_keys
    result <- as.vector(sapply(team_keys, parse_team_key), mode = "numeric")
    return(result)
}

# This function returns the data for a given team in a given year.

get_team_data <- function(team_number, year.) { # nolint
    if (year. == 2022) {
        result <- all_data_2022[all_data_2022$team_number == team_number,] # nolint
        rownames(result) <- NULL
        return(result)
    } else if (year. == 2023) {
        result <- all_data_2023[all_data_2023$team_number == team_number,] # nolint
        rownames(result) <- NULL
        return(result)
    }
}

is_qual <- \(match_data) match_data$comp_level == "qm"

get_teams_at_event <- function(event) { # nolint
    event_teams_json_raw <- GET(paste0(tba_base_url, "event/", event, "/teams"), add_headers("X-TBA-Auth-Key" = tba_api_token)) # nolint
    event_teams_json <- content(event_teams_json_raw, as = "text")
    event_teams <- fromJSON(event_teams_json)
    event_team_numbers <- event_teams$team_number |> unlist()
    return(event_team_numbers)
}

number_of_links <- \(match_data, alliance = c("red", "blue")) as.data.frame(match_data$score_breakdown[[alliance]]$links) |> nrow() # nolint

all_events_pnw_2023 <- { # nolint
    { # nolint
        paste0(tba_base_url, "/district/2023pnw/events") |>
        GET(add_headers("X-TBA-Auth-Key" = tba_api_token)) |>
        content(as = "text") |>
        fromJSON()
    }$key # nolint
}

selected_events_2023 <- c("2023wasno", "2023waahs", "2023pncmp")

get_matches_at_event <- function(event_key) {
    matches_at_event <- {
        paste0(tba_base_url, "event/", event_key, "/matches") |>
        GET(add_headers("X-TBA-Auth-Key" = tba_api_token)) |>
        content(as = "text") |>
        fromJSON() |>
        filter(comp_level == "qm") # nolint
    }
    return(matches_at_event)
}

all_matches_pnw_2023 <- lapply(all_events_pnw_2023, get_matches_at_event) |> bind_rows()

team_in_match <- \(team, match_data) team %in% lapply(unlist(c(match_data$alliances$red$team_keys, match_data$alliances$blue$team_keys)), parse_team_key) # nolint
match_has_team <- \(match_data, team) team_in_match(team, match_data)

get_team_matches_2023 <- function(team) { # works
    result <- list()
    for (i in seq_len(nrow(all_matches_pnw_2023))) {
        if (team_in_match(team, as.list(all_matches_pnw_2023[i,]))) { # nolint
            result <- bind_rows(result, as.list(all_matches_pnw_2023[i,])) # nolint
        }
    }
    return(result)
}

get_team_alliance <- function(team, match_data) {
    if (team %in% unlist(lapply(match_data$alliances$red$team_keys, parse_team_key))) {
        return("red")
    } else if (team %in% unlist(lapply(match_data$alliances$blue$team_keys, parse_team_key))) {
        return("blue")
    }
}

get_winning_alliance <- \(match_data) match_data$winning_alliance

grand_mean_links <- mean(c(all_matches_pnw_2023$score_breakdown$red$links |> lapply(as.data.frame) |> lapply(nrow) |> unlist() |> mean(), all_matches_pnw_2023$score_breakdown$blue$links |> lapply(as.data.frame) |> lapply(nrow) |> unlist() |> mean())) # nolint

get_team_mean_links <- function(team) {
    team_matches_2023 <- get_team_matches_2023(team)
    link_counts <- c()
    for (i in seq_len(nrow(team_matches_2023))) {
        match_data <- as.list(team_matches_2023[i,]) # nolint
        alliance <- get_team_alliance(team, match_data)
        link_counts <- c(link_counts, number_of_links(match_data, alliance))
    }
    result <- mean(link_counts)
    return(result)
}

get_team_mean_link_contribution <- \(team) (grand_mean_links / 3) + get_team_mean_links(team) - grand_mean_links # nolint

calculate_est_team_link_contribution <- \(match_data, team) (get_team_mean_link_contribution(team) / sum(unlist(lapply(get_teams_on_alliance_in_match_from_data(match_data, get_team_alliance(team, match_data)), get_team_mean_link_contribution)))) * number_of_links(match_data, get_team_alliance(team, match_data)) # nolint

team_won_match <- \(team, match_data) get_team_alliance(team, match_data) == get_winning_alliance(match_data)

check_win <- \(dfrow, yr) team_won_match(dfrow$team_number, get_match_data_from_tba(dfrow$event, yr, dfrow$match_number)) # nolint

# if (!file.exists("all_data_2022.csv") || !file.exists("all_data_2023.csv")) {
#     all_data_2022$won_match <- (function() {
#         result <- c()
#         for (i in seq_len(all_data_2022 |> nrow())) {
#             oldlen <- length(result)
#             result <- c(result, all_data_2022[i,] |> check_win(2022))
#             if (length(result) == oldlen) {
#                 result <- c(result, FALSE)
#             }
#         }
#         return(result)
#     })()
#     all_data_2023$won_match <- (function() {
#         result <- c()
#         for (i in seq_len(all_data_2023 |> nrow())) {
#             oldlen <- length(result)
#             result <- c(result, all_data_2023[i,] |> check_win(2023))
#             if (length(result) == oldlen) {
#                 result <- c(result, FALSE)
#             }
#         }
#         return(result)
#     })()
# }

all_data_2022$won_match <- (function() {
    result <- c()
    for (i in seq_len(all_data_2022 |> nrow())) {
        oldlen <- length(result)
        result <- c(result, all_data_2022[i,] |> check_win(2022))
        if (length(result) == oldlen) {
            result <- c(result, FALSE)
        }
    }
    return(result)
})()
all_data_2023$won_match <- (function() {
    result <- c()
    for (i in seq_len(all_data_2023 |> nrow())) {
        oldlen <- length(result)
        result <- c(result, all_data_2023[i,] |> check_win(2023))
        if (length(result) == oldlen) {
            result <- c(result, FALSE)
        }
    }
    return(result)
})()

write.csv(all_data_2022, "all_data_2022.csv")
write.csv(all_data_2023, "all_data_2023.csv")

calculate_win_rate <- function(team, year) {
    count <- 0
    wins <- 0
    dataset <- if (year == 2022) all_data_2022 else if (year == 2023) all_data_2023 else NA
    for (i in seq_len(dataset |> nrow())) {
        if (dataset[i,]$team_number == team) {
            count <- count + 1
            if (dataset[i,]$won_match) {
                wins <- wins + 1
            }
        }
    }
    if (count == 0) {
        return(NA)
    }
    return(wins / count)
}
```

```{r include=F}
pt_teams |> write.csv("qdata_immutable.csv")
if (!file.exists("qdata.csv")) {
    file.copy("qdata_immutable.csv", "qdata.csv")
}
```

```{r include=F}
team_data <- read.csv("qdata.csv")[2:5]
colnames(team_data)[3] <- "dt_type"
colnames(team_data)[4] <- "eps" # school expenditure per student in 2017 from ocrdata.ed.gov
team_data$win_rate <- (function() {
    result <- c()
    for (i in seq_len(team_data |> nrow())) {
        result <- c(result, calculate_win_rate(team_data[i,]$team, team_data[i,]$year))
    }
    return(result)
})()
team_data_2022 <- team_data[team_data$year == 2022,] |> data.frame()
team_data_2023 <- team_data[team_data$year == 2023,] |> data.frame()
```

\section{Findings}

```{r tests, include=F}
dt_ttest <- t.test(win_rate ~ dt_type, data = team_data)

exp_lm <- lm(win_rate ~ eps, data = team_data)

team_age_lm <- lm(win_rate ~ team, data = team_data)
```

```{r models, include=F}
wr_lm <- lm(win_rate ~ dt_type + eps + team, data = team_data)
```

\section{Analysis}

\section{Conclusion}

\section{Bibliography}